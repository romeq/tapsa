// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: account.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM 
    account
WHERE 
    account_id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, accountID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, accountID)
	return err
}

const deleteSession = `-- name: DeleteSession :one
DELETE FROM account_session
WHERE
    account_session.session_id = $2 
    AND account_session.account_id = get_userid_by_session($1)
RETURNING session_id
`

type DeleteSessionParams struct {
	SessionID   string `json:"session_id"`
	SessionID_2 string `json:"session_id_2"`
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteSession, arg.SessionID, arg.SessionID_2)
	var session_id string
	err := row.Scan(&session_id)
	return session_id, err
}

const deleteSessions = `-- name: DeleteSessions :many
DELETE FROM account_session
WHERE account_id = get_userid_by_session($1)
RETURNING session_id
`

func (q *Queries) DeleteSessions(ctx context.Context, sessionID string) ([]string, error) {
	rows, err := q.db.Query(ctx, deleteSessions, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var session_id string
		if err := rows.Scan(&session_id); err != nil {
			return nil, err
		}
		items = append(items, session_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountPasswordHash = `-- name: GetAccountPasswordHash :one
SELECT 
    password 
FROM 
    account
WHERE 
    username = $1
`

func (q *Queries) GetAccountPasswordHash(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, getAccountPasswordHash, username)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getSessionAccount = `-- name: GetSessionAccount :one
SELECT 
    a.account_id,
    a.username,
    a.register_date,
    a.last_login,
    a.activity_points
FROM 
    account_session AS ac
JOIN 
    account AS a USING(account_id)
WHERE 
    ac.session_id = $1
    AND 
    CURRENT_TIMESTAMP - ac.start_date < ac.expire_date - ac.start_date
`

type GetSessionAccountRow struct {
	AccountID      uuid.UUID `json:"account_id"`
	Username       string    `json:"username"`
	RegisterDate   time.Time `json:"register_date"`
	LastLogin      time.Time `json:"last_login"`
	ActivityPoints int32     `json:"activity_points"`
}

func (q *Queries) GetSessionAccount(ctx context.Context, sessionID string) (GetSessionAccountRow, error) {
	row := q.db.QueryRow(ctx, getSessionAccount, sessionID)
	var i GetSessionAccountRow
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.RegisterDate,
		&i.LastLogin,
		&i.ActivityPoints,
	)
	return i, err
}

const getSessions = `-- name: GetSessions :many
SELECT 
    session_id, start_date
FROM
    account_session AS ac
WHERE 
    account_id = get_userid_by_session($1)
    AND 
    CURRENT_TIMESTAMP - ac.start_date < ac.expire_date - ac.start_date
`

type GetSessionsRow struct {
	SessionID string    `json:"session_id"`
	StartDate time.Time `json:"start_date"`
}

func (q *Queries) GetSessions(ctx context.Context, sessionID string) ([]GetSessionsRow, error) {
	rows, err := q.db.Query(ctx, getSessions, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsRow{}
	for rows.Next() {
		var i GetSessionsRow
		if err := rows.Scan(&i.SessionID, &i.StartDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newAccount = `-- name: NewAccount :one
INSERT INTO account(
    username, 
    password
)
VALUES ($1, $2)
RETURNING account_id, username, password, register_date, last_login, activity_points
`

type NewAccountParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) NewAccount(ctx context.Context, arg NewAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, newAccount, arg.Username, arg.Password)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.RegisterDate,
		&i.LastLogin,
		&i.ActivityPoints,
	)
	return i, err
}

const newAccountSession = `-- name: NewAccountSession :one
INSERT INTO account_session(
    session_id,
    account_id,
    expire_date
) VALUES(
    $1,
    ( SELECT account_id FROM account WHERE username = $2 ),
    $3
) RETURNING session_id
`

type NewAccountSessionParams struct {
	SessionID  string    `json:"session_id"`
	Username   string    `json:"username"`
	ExpireDate time.Time `json:"expire_date"`
}

func (q *Queries) NewAccountSession(ctx context.Context, arg NewAccountSessionParams) (string, error) {
	row := q.db.QueryRow(ctx, newAccountSession, arg.SessionID, arg.Username, arg.ExpireDate)
	var session_id string
	err := row.Scan(&session_id)
	return session_id, err
}

const resetPassword = `-- name: ResetPassword :one
UPDATE 
    account 
SET 
    password = $1
WHERE 
    account_id = $2
RETURNING 
    username
`

type ResetPasswordParams struct {
	Password  string    `json:"password"`
	AccountID uuid.UUID `json:"account_id"`
}

func (q *Queries) ResetPassword(ctx context.Context, arg ResetPasswordParams) (string, error) {
	row := q.db.QueryRow(ctx, resetPassword, arg.Password, arg.AccountID)
	var username string
	err := row.Scan(&username)
	return username, err
}
