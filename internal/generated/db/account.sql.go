// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: account.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM 
    account
WHERE 
    account_id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, accountID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, accountID)
	return err
}

const deleteSession = `-- name: DeleteSession :one
DELETE FROM account_session
WHERE
    account_session.session_id = $2 
    AND account_session.account_id = (
        SELECT account_id
        FROM account_session AS acse
        WHERE acse.session_id = $1
    )
RETURNING session_id, account_id, start_date
`

type DeleteSessionParams struct {
	SessionID   string `json:"session_id"`
	SessionID_2 string `json:"session_id_2"`
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) (AccountSession, error) {
	row := q.db.QueryRow(ctx, deleteSession, arg.SessionID, arg.SessionID_2)
	var i AccountSession
	err := row.Scan(&i.SessionID, &i.AccountID, &i.StartDate)
	return i, err
}

const deleteSessions = `-- name: DeleteSessions :many
DELETE FROM account_session
WHERE account_id = (
    SELECT account_id
    FROM account_session AS acse
    WHERE acse.session_id = $1
)
RETURNING session_id, account_id, start_date
`

func (q *Queries) DeleteSessions(ctx context.Context, sessionID string) ([]AccountSession, error) {
	rows, err := q.db.Query(ctx, deleteSessions, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountSession{}
	for rows.Next() {
		var i AccountSession
		if err := rows.Scan(&i.SessionID, &i.AccountID, &i.StartDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountPasswordHash = `-- name: GetAccountPasswordHash :one
SELECT 
    password 
FROM 
    account
WHERE 
    username = $1
`

func (q *Queries) GetAccountPasswordHash(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, getAccountPasswordHash, username)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getSessionAccount = `-- name: GetSessionAccount :one
SELECT 
    a.account_id,
    a.username,
    a.register_date,
    a.last_login,
    a.activity_points
FROM 
    account_session AS ac
JOIN 
    account AS a ON a.account_id = ac.account_id
WHERE ac.session_id = $1
`

type GetSessionAccountRow struct {
	AccountID      uuid.UUID `json:"account_id"`
	Username       string    `json:"username"`
	RegisterDate   time.Time `json:"register_date"`
	LastLogin      time.Time `json:"last_login"`
	ActivityPoints int32     `json:"activity_points"`
}

func (q *Queries) GetSessionAccount(ctx context.Context, sessionID string) (GetSessionAccountRow, error) {
	row := q.db.QueryRow(ctx, getSessionAccount, sessionID)
	var i GetSessionAccountRow
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.RegisterDate,
		&i.LastLogin,
		&i.ActivityPoints,
	)
	return i, err
}

const getSessions = `-- name: GetSessions :many
SELECT 
    session_id, start_date
FROM
    account_session
WHERE account_id = (
    SELECT account_id 
    FROM account_session AS ases
    WHERE ases.session_id = $1
)
`

type GetSessionsRow struct {
	SessionID string    `json:"session_id"`
	StartDate time.Time `json:"start_date"`
}

func (q *Queries) GetSessions(ctx context.Context, sessionID string) ([]GetSessionsRow, error) {
	rows, err := q.db.Query(ctx, getSessions, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsRow{}
	for rows.Next() {
		var i GetSessionsRow
		if err := rows.Scan(&i.SessionID, &i.StartDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newAccount = `-- name: NewAccount :one
INSERT INTO account(
    username, 
    password
)
VALUES ($1, $2)
RETURNING account_id, username, password, register_date, last_login, activity_points
`

type NewAccountParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) NewAccount(ctx context.Context, arg NewAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, newAccount, arg.Username, arg.Password)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.RegisterDate,
		&i.LastLogin,
		&i.ActivityPoints,
	)
	return i, err
}

const newSession = `-- name: NewSession :one
INSERT INTO account_session(
    session_id, 
    account_id
)
VALUES 
    ($1, (
        SELECT account_id 
        FROM account
        WHERE username = $2
    ))
RETURNING 
    session_id
`

type NewSessionParams struct {
	SessionID string `json:"session_id"`
	Username  string `json:"username"`
}

func (q *Queries) NewSession(ctx context.Context, arg NewSessionParams) (string, error) {
	row := q.db.QueryRow(ctx, newSession, arg.SessionID, arg.Username)
	var session_id string
	err := row.Scan(&session_id)
	return session_id, err
}

const resetPassword = `-- name: ResetPassword :one
UPDATE 
    account 
SET 
    password = $1
WHERE 
    account_id = $2
RETURNING 
    username
`

type ResetPasswordParams struct {
	Password  string    `json:"password"`
	AccountID uuid.UUID `json:"account_id"`
}

func (q *Queries) ResetPassword(ctx context.Context, arg ResetPasswordParams) (string, error) {
	row := q.db.QueryRow(ctx, resetPassword, arg.Password, arg.AccountID)
	var username string
	err := row.Scan(&username)
	return username, err
}
